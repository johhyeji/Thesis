import numpy as np
import pandas as pd
import geopandas as gpd
from typing import Tuple
from ..rules.rule_dataclass import RuleSet
from ..rules.parser import RuleParser
from ..preprocessing.template_modifier import BUILDING_CLASSES

"""
CityStackGen output run with 

---- Groningen_NL_modified.npz  ---- (from preprocessing.py)

is in:

../citystack/citystackgen/outputs/Groningen_modified/

"""

"""
Postprocessing:
- Classifying building geometries generated by CityStackGen
- different data structure from preprocessing, same euclidean distance algorithm

- read geojson file of CityStackGen building polygons
- for each bldg polygon:
    - calculate centorid
    - calculate dist to city center
    - find zone
    - apply housing rule
    - assign building type
- save classified bldg polygons to a new geojson file

"""

def load_buildings_from_geojson(geojson_path: str) -> gpd.GeoDataFrame:
    buildings_gdf = gpd.read_file(geojson_path)
    
    # get centroids
    buildings_gdf['centroid'] = buildings_gdf.geometry.centroid
    buildings_gdf['x'] = buildings_gdf['centroid'].x
    buildings_gdf['y'] = buildings_gdf['centroid'].y
    
    # calculate area
    buildings_gdf['area_m2'] = buildings_gdf.geometry.area
    
    return buildings_gdf


def get_city_center_from_geojson(geojson_path: str) -> Tuple[float, float]:

    city_center_gdf = gpd.read_file(geojson_path)
    
    # Extract point coordinates
    point = city_center_gdf.geometry.iloc[0]
    center_x = point.x
    center_y = point.y
    
    return (center_x, center_y)


class BuildingProcessor:

    def __init__(self, rules: RuleSet, random_seed: int = 123):
        self.rules = rules
        # Create independent random generator for reproducibility
        self.rng = np.random.default_rng(random_seed)
        
    # process buildings based on zone rules
    def process_buildings(
        self,
        buildings_df: pd.DataFrame,
        city_center: Tuple[float, float]
    ) -> pd.DataFrame:

        """ 
        Process buildings by calculating distances, assigning zones, and classifying types
        
        Args:
            buildings_df: DataFrame with columns ['building_id', 'x', 'y'], where x, y are bldg centroid coords
            city_center: (x, y) coords of city center
        Returns:
            DataFrame with columns ['distance', 'zone', 'building_class', 'building_type', 'household_type']
        """

        # make a copy
        result_df = buildings_df.copy()

        # 1. calculate dists
        result_df['distance'] = result_df.apply(
            lambda row: self._calculate_distance(
                row['x'], row['y'], city_center[0], city_center[1]
            ),
            axis=1
        )
        # 2. assign zones
        result_df['zone'] = result_df['distance'].apply(
            lambda d: self._get_zone_name(d)
        )

        # 3. assign bldg types
        result_df['building_type'] = result_df['zone'].apply(
            lambda z: self._sample_building_type(z)
        )
        
        # 4. assign bldg class 
        result_df['building_class'] = result_df['building_type'].apply(
            lambda t: BUILDING_CLASSES.get(t, 99)
        )
        
        # 5. assign unit sizes (only for residential buildings)
        result_df['unit_size'] = result_df.apply(
            lambda row: self._sample_unit_size(row['zone']) 
                        if row['building_type'] != 'none' else 0.0,
            axis=1
        )
        
        # 6. assign household types (only for residential buildings)
        result_df['household_type'] = result_df.apply(
            lambda row: self._sample_household_type(row['zone']) 
                        if row['building_type'] != 'none' else 'none',
            axis=1
        )
        
        # 7. assign household counts based on unit size and building area
        result_df['household_count'] = result_df.apply(
            lambda row: self._calculate_household_count(row) 
                        if row['building_type'] != 'none' else 0,
            axis=1
        )
        
        # 8. assign resident counts based on household type
        result_df['resident_count'] = result_df.apply(
            lambda row: self._calculate_resident_count(row) 
                        if row['building_type'] != 'none' else 0,
            axis=1
        )

        return result_df

    # calc distance to city center
    def _calculate_distance(
        self, 
        x: float,
        y: float,
        center_x: float, 
        center_y: float
    ) -> float:
        return np.sqrt((x - center_x)**2 + (y - center_y)**2)

    # find which zone a distance belons to
    def _get_zone_name(self, distance: float) -> str:
        zone = self.rules.get_zone(distance)
        return zone.name if zone else "unknown"

    # sample bldg type based on probabilities
    # TODO: constraints?
    def _sample_building_type(self, zone_name: str) -> str:
        rule = self.rules.get_housing_rule(zone_name)
        
        if rule is None:
            return "none"
        
        types = ['apartment', 'detached', 'terraced']
        probabilities = [rule.apartment_pct, rule.detached_pct, rule.terraced_pct]

        return self.rng.choice(types, p = probabilities)
    
    # sample household type based on probabilities
    def _sample_household_type(self, zone_name: str) -> str:
        rule = self.rules.get_household_rule(zone_name)
        
        if rule is None:
            return "none"
        
        types = ['single_person', 'single_parent', 'two_parent']
        probabilities = [rule.single_person_pct, rule.single_parent_pct, rule.two_parent_pct]
        
        return self.rng.choice(types, p=probabilities)
    
    # sample unit size based on probs
    def _sample_unit_size(self, zone_name: str) -> float:
        rule = self.rules.get_unit_size_rule(zone_name)
        
        if rule is None:
            return 60.0  # Default unit size
        
        # sample from uniform distribution between min and max ###TODO: uniform distribution?
        return self.rng.uniform(rule.min_size, rule.max_size)
    
    # calculate household count based on bldg area and unit size
    def _calculate_household_count(self, row) -> int:
        building_area = row.get('area_m2', 100.0)  # default area if not available
        unit_size = row['unit_size']
        
        if unit_size <= 0:
            return 0
        
        # calculate how many units fit in the bldg
        household_count = max(1, int(building_area / unit_size))
        return household_count
    
    # calculate resident count based on household type
    def _calculate_resident_count(self, row) -> int:
        household_type = row['household_type']
        household_count = row['household_count']
        
        if household_type == 'none':
            return 0
        
        # calculate residents per household based on type
        residents_per_household = self._calculate_household_size(household_type)
        return household_count * residents_per_household
    
    # calculate number of residents in a single household based on household type
    def _calculate_household_size(self, household_type: str) -> int:
        if household_type == 'single_person':
            return 1
        
        elif household_type == 'single_parent':
            # 1 parent + 1-3 children
            num_children = self.rng.integers(1, 4)  # 1, 2, or 3 children
            return 1 + num_children
        
        elif household_type == 'two_parent':
            # 2 parents + 1-3 children
            num_children = self.rng.integers(1, 4)  # 1, 2, or 3 children
            return 2 + num_children
        
        else:
            return 1  # fallback

    