import numpy as np
import pandas as pd
import geopandas as gpd
from typing import Tuple
from rule_dataclass import RuleSet
from rule_dataclass import load_rules_from_yaml
from preprocessing import BUILDING_CLASSES

"""
CityStackGen output run with 

---- Groningen_NL_modified.npz  ---- (from preprocessing.py)

is in:

../citystack/citystackgen/outputs/Groningen_modified/

"""

"""
Postprocessing:
- Classifying building geometries generated by CityStackGen
- different data structure from preprocessing, same euclidean distance algorithm

- read geojson file of CityStackGen building polygons
- for each bldg polygon:
    - calculate centorid
    - calculate dist to city center
    - find zone
    - apply housing rule
    - assign building type
- save classified bldg polygons to a new geojson file

"""

def load_buildings_from_geojson(geojson_path: str) -> gpd.GeoDataFrame:
    buildings_gdf = gpd.read_file(geojson_path)
    
    print(f"  Loaded {len(buildings_gdf)} buildings")
    print(f"  CRS: {buildings_gdf.crs}")
    print(f"  Geometry type: {buildings_gdf.geom_type.iloc[0]}")
    
    # get centroids
    buildings_gdf['centroid'] = buildings_gdf.geometry.centroid
    buildings_gdf['x'] = buildings_gdf['centroid'].x
    buildings_gdf['y'] = buildings_gdf['centroid'].y
    
    # calculate area
    buildings_gdf['area_m2'] = buildings_gdf.geometry.area
    
    return buildings_gdf


def get_city_center_from_geojson(geojson_path: str) -> Tuple[float, float]:

    city_center_gdf = gpd.read_file(geojson_path)
    
    # Extract point coordinates
    point = city_center_gdf.geometry.iloc[0]
    center_x = point.x
    center_y = point.y
    
    print(f"City center from CityStackGen: ({center_x:.0f}, {center_y:.0f})")
    return (center_x, center_y)


class BuildingClassifier:

    def __init__(self, rules: RuleSet, random_seed: int = 123):
        self.rules = rules
        # Create independent random generator for reproducibility
        self.rng = np.random.default_rng(random_seed)
        print(f"  Initialized with random seed: {random_seed}")

    # classify bldgs based on zone rules
    def classify_buildings(
        self,
        buildings_df: pd.DataFrame,
        city_center: Tuple[float, float]
    ) -> pd.DataFrame:

        """ 
        Args:
            buildings_df: DataFrame with columns ['building_id', 'x', 'y'], where x, y are bldg centroid coords
            city_center: (x, y) coords of city center
        Returns:
            DataFrame with columns ['distance', 'zone', 'building_class', 'building_type']
        """

        print(f"\n{'='*60}")
        print("POSTPROCESSING: Classifying Buildings")
        print('='*60)

        print(f"\nBuildings to classify: {len(buildings_df)}")
        print(f"City center: ({city_center[0]:.0f}, {city_center[1]:.0f})")

        # make a copy
        result_df = buildings_df.copy()

        # 1. calculate dists
        print("\n1. Calculating distances to city center...")
        result_df['distance'] = result_df.apply(
            lambda row: self._calculate_distance(
                row['x'], row['y'], city_center[0], city_center[1]
            ),
            axis=1
        )
        # 2. assign zones
        print("2. Assigning zones...")
        result_df['zone'] = result_df['distance'].apply(
            lambda d: self._get_zone_name(d)
        )

        # 3. assign bldg types
        print("3. Sampling building types...")
        result_df['building_type'] = result_df['zone'].apply(
            lambda z: self._sample_building_type(z)
        )
        
        # 4. assign bldg class 
        result_df['building_class'] = result_df['building_type'].apply(
            lambda t: BUILDING_CLASSES.get(t, 99)
        )
        
        # 5. assign household types (only for residential buildings)
        print("4. Assigning household types...")
        result_df['household_type'] = result_df.apply(
            lambda row: self._sample_household_type(row['zone']) 
                        if row['building_type'] != 'none' else 'none',
            axis=1
        )

        # print statistics
        self._print_statistics(result_df)
        
        return result_df

    # calc distance to city center
    def _calculate_distance(
        self, 
        x: float,
        y: float,
        center_x: float, 
        center_y: float
    ) -> float:
        return np.sqrt((x - center_x)**2 + (y - center_y)**2)

    # find which zone a distance belons to
    def _get_zone_name(self, distance: float) -> str:
        zone = self.rules.get_zone(distance)
        return zone.name if zone else "unknown"

    # sample bldg type based on probabilities
    # TODO: constraints?
    def _sample_building_type(self, zone_name: str) -> str:
        rule = self.rules.get_housing_rule(zone_name)
        
        if rule is None:
            return "none"
        
        types = ['apartment', 'detached', 'terraced']
        probabilities = [rule.apartment_pct, rule.detached_pct, rule.terraced_pct]

        return self.rng.choice(types, p = probabilities)
    
    # sample household type based on probabilities
    def _sample_household_type(self, zone_name: str) -> str:
        rule = self.rules.get_household_rule(zone_name)
        
        if rule is None:
            return "none"
        
        types = ['single_person', 'single_parent', 'two_parent']
        probabilities = [rule.single_person_pct, rule.single_parent_pct, rule.two_parent_pct]
        
        return self.rng.choice(types, p=probabilities)

    def _print_statistics(self, df: pd.DataFrame):
        print(f"\n{'='*60}")
        print("POSTPROCESSING: Statistics")
        print('='*60)
        
        total = len(df)
        
        print(f"\nTotal buildings: {total}")
        
        # by zone
        print(f"\nBuildings by zone:") 
        zone_counts = df['zone'].value_counts().sort_index()
        for zone, count in zone_counts.items():
            pct = (count / total) * 100
            print(f"  {zone:15s}: {count:4d} buildings ({pct:5.1f}%)")
        
        # by type
        print(f"\nBuildings by type:")
        type_counts = df['building_type'].value_counts()
        for btype, count in type_counts.items():
            pct = (count / total) * 100
            print(f"  {btype:15s}: {count:4d} buildings ({pct:5.1f}%)")
        
        # by household type
        if 'household_type' in df.columns:
            print(f"\nBuildings by household type:")
            household_counts = df['household_type'].value_counts()
            for htype, count in household_counts.items():
                pct = (count / total) * 100
                print(f"  {htype:15s}: {count:4d} buildings ({pct:5.1f}%)")

        # by zone and type
        print(f"\nBreakdown by zone, building type, and household type:")
        for zone in sorted(df['zone'].unique()):
            zone_df = df[df['zone'] == zone]
    
            apt_count = len(zone_df[zone_df['building_type'] == 'apartment'])
            det_count = len(zone_df[zone_df['building_type'] == 'detached'])
            ter_count = len(zone_df[zone_df['building_type'] == 'terraced'])
            none_count = len(zone_df[zone_df['building_type'] == 'none'])
            single_person_count = len(zone_df[zone_df['household_type'] == 'single_person'])
            single_parent_count = len(zone_df[zone_df['household_type'] == 'single_parent'])
            two_parent_count = len(zone_df[zone_df['household_type'] == 'two_parent'])
            none_count = len(zone_df[zone_df['household_type'] == 'none'])
            total_zone = len(zone_df)
            
            apt_pct = (apt_count / total_zone * 100) if total_zone > 0 else 0
            det_pct = (det_count / total_zone * 100) if total_zone > 0 else 0
            ter_pct = (ter_count / total_zone * 100) if total_zone > 0 else 0
            
            # DETAILED break down for zone, mimicking test_preprocessing.py style for expected percentages:
            print(f"  {zone:15s}:")
            # Show actual by building type, with expected from housing rule if available
            if hasattr(self, "rules") and hasattr(self.rules, "get_housing_rule"):
                housing_rule = self.rules.get_housing_rule(zone)
            else:
                housing_rule = None

            # Apartments
            expected_apt_pct = housing_rule.apartment_pct * 100 if housing_rule else None
            apt_line = f"    Apartments        : {apt_count:4d} ({apt_pct:5.1f}%)"
            if expected_apt_pct is not None:
                apt_line += f" [expected {expected_apt_pct:.0f}%]"
            print(apt_line)
            
            # Detached
            expected_det_pct = housing_rule.detached_pct * 100 if housing_rule else None
            det_line = f"    Detached houses   : {det_count:4d} ({det_pct:5.1f}%)"
            if expected_det_pct is not None:
                det_line += f" [expected {expected_det_pct:.0f}%]"
            print(det_line)
            
            # Terraced
            expected_ter_pct = housing_rule.terraced_pct * 100 if housing_rule else None
            ter_line = f"    Terraced houses   : {ter_count:4d} ({ter_pct:5.1f}%)"
            if expected_ter_pct is not None:
                ter_line += f" [expected {expected_ter_pct:.0f}%]"
            print(ter_line)
            
            # Household types (not in test_preprocessing.py - leave as is)
            single_person_pct = single_person_count / total_zone * 100 if total_zone > 0 else 0
            single_parent_pct = single_parent_count / total_zone * 100 if total_zone > 0 else 0
            two_parent_pct = two_parent_count / total_zone * 100 if total_zone > 0 else 0
            none_pct = none_count / total_zone * 100 if total_zone > 0 else 0

            print(f"    Single person     : {single_person_count:4d} ({single_person_pct:5.1f}%)")
            print(f"    Single parent     : {single_parent_count:4d} ({single_parent_pct:5.1f}%)")
            print(f"    Two parent family : {two_parent_count:4d} ({two_parent_pct:5.1f}%)")
            print(f"    None              : {none_count:4d} ({none_pct:5.1f}%)")
        print('='*60)


# -------------
# FULL PIPELINE
def postprocess_citystackgen_output(
    buildings_geojson: str,
    city_center_geojson: str,
    rules_yaml: str,
    output_geojson: str = None,
    output_csv: str = None
) -> gpd.GeoDataFrame:
    
    """
    Complete postprocessing pipeline using CityStackGen outputs.
    
    1. load bldg polygons from CityStackGen GeoJSON
    2. extract centroids
    3. get city center from CityStackGen GeoJSON (not NPZ!)
    4. load rules from YAML
    5. classify buildings based on zones and housing rules
    6. assign household types to each building
    7. save classified buildings with household types

    """
    print("="*70)
    print("POSTPROCESSING PIPELINE")
    print("="*70)
    
    # 1. load bldg polygons from CityStackGen output
    print("\n[1] Loading buildings from CityStackGen output...")
    buildings_gdf = load_buildings_from_geojson(buildings_geojson)
    
    # 2. get city center from CityStackGen output
    print("\n[2] Getting city center from CityStackGen output...")
    city_center = get_city_center_from_geojson(city_center_geojson)
    
    # 3. load rules
    print("\n[3] Loading rules...")
    rules = load_rules_from_yaml(rules_yaml)
    print(f"  Loaded {len(rules.zones)} zones")
    print(f"  Loaded {len(rules.housing_rules)} housing rules")
    
    # 4. classify buildings
    print("\n[4] Classifying buildings...")
    classifier = BuildingClassifier(rules, random_seed=123)
    
    # extract data for classification
    buildings_df = pd.DataFrame({
        'building_id': range(len(buildings_gdf)),
        'x': buildings_gdf['x'],
        'y': buildings_gdf['y']
    })
    
    classified_df = classifier.classify_buildings(buildings_df, city_center)
    
    # 5. merge classifications back to GeoDataFrame
    print("\n[5] Merging classifications to GeoDataFrame...")
    buildings_gdf['building_id'] = classified_df['building_id']
    buildings_gdf['distance'] = classified_df['distance'].values
    buildings_gdf['zone'] = classified_df['zone'].values
    buildings_gdf['building_type'] = classified_df['building_type'].values
    buildings_gdf['building_class'] = classified_df['building_class'].values
    buildings_gdf['household_type'] = classified_df['household_type'].values
    
    # 6. save outputs to geojson and csv
    if output_geojson:
        print(f"\n[6] Saving classified buildings to GeoJSON...")
        # drop centroid column
        buildings_gdf_final = buildings_gdf.drop(columns=['centroid'], errors='ignore')
        buildings_gdf_final.to_file(output_geojson, driver='GeoJSON')
        print(f"  Saved to: {output_geojson}")
    
    if output_csv:
        print(f"\n[6] Saving classified buildings to CSV...")
        # save to csv,dropped centroid column
        buildings_gdf_final.to_csv(output_csv, index=False)
        print(f"  Saved to: {output_csv}")
    
    print("\n" + "="*70)
    print("POSTPROCESSING COMPLETE")
    print("="*70)
    print(f"\nClassified {len(buildings_gdf)} buildings")
    print(f"Output files:")
    if output_geojson:
        print(f"  - {output_geojson} (GeoJSON with geometries)")
    if output_csv:
        print(f"  - {output_csv} (CSV for analysis)")
    print("="*70)
    
    return buildings_gdf


def main():
    classified_buildings = postprocess_citystackgen_output(
        buildings_geojson="../citystack/citystackgen/outputs/Groningen_modified/buildings.geojson",
        city_center_geojson="../citystack/citystackgen/outputs/Groningen_modified/city_center.geojson",
        rules_yaml="rule.yaml",
        output_geojson="buildings_classified.geojson",
        output_csv="buildings_classified.csv"
    )
    
    print("\n" + "="*70)
    print("âœ… POSTPROCESSING COMPLETE")
    
if __name__ == "__main__":
    main()
